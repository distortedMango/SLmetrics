# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Accuracy
#'
#' Calculate the proportion of correct predictions.
#'
#' @usage
#' accuracy(
#'   actual,
#'   predicted
#' )
#'
#' @inheritParams cmatrix
#'
#' @returns A <[numeric]>-vector of [length] 1
#'
#' @example man/examples/scr_accuracy.R
#'
#' @family classification
#'
#' @export
accuracy <- function(actual, predicted) {
    .Call(`_SLmetrics_accuracy`, actual, predicted)
}

#' Confusion Matrix
#'
#' @description
#' Placeholder
#'
#' @usage
#' cmatrix(
#'   actual,
#'   predicted
#' )
#'
#' @param actual A <[factor]>-vector of length n, and k levels.
#' @param predicted A <[factor]>-vector of length n.
#'
#' @example man/examples/scr_confusionmatrix.R
#' @family classification
#'
#' @details
#'
#' If the function is correctly implemented the resulting
#' confusion matrix is given as,
#'
#'
#' |            | A (Predicted)        | B (Predicted)   |
#' | ------------- |:-------------:| -----:|
#' | A (Actual)   | Value     | Value |
#' | B  (Actual)   |  Value    |  Value   |
#'
#'
#' @returns A named k x k <[matrix]>
#'
#' @export
cmatrix <- function(actual, predicted) {
    .Call(`_SLmetrics_cmatrix`, actual, predicted)
}

#' Diagnostic Odds Ratio (DOR)
#' @usage
#' # 3) `dor()`-function
#' dor(
#'   actual,
#'   predicted,
#'   aggregate = FALSE
#' )
#'
#' @inherit specificity
#'
#' @family classification
#' @export
dor <- function(actual, predicted, aggregate = FALSE) {
    .Call(`_SLmetrics_dor`, actual, predicted, aggregate)
}

#' Generalized F Score
#'
#' @description
#' Calculate the F Score
#'
#' @usage
#' fbeta(
#'   actual,
#'   predicted,
#'   beta = 1,
#'   aggregate = FALSE
#' )
#'
#' @inheritParams cmatrix
#' @param beta A <[numeric]> vector of length 1. 1 by default, see details.
#' @param aggregate A <[logical]>-value of [length] 1. [FALSE] by default. If [TRUE] it returns the
#' micro average across all k-classes
#'
#' @details
#' The general F-score equation is given as follows,
#'
#' \deqn{F_{\beta} = (1+\beta^2) \frac{precision \times recall}{\beta^2 \times precision + recall}}
#'
#' if \eqn{\beta = 1} then it corresponds to the traditional F1 score.
#'
#' @returns
#' A named <[numeric]> vector of length k
#'
#' @family classification
#'
fbeta <- function(actual, predicted, beta = 1.0, aggregate = FALSE) {
    .Call(`_SLmetrics_fbeta`, actual, predicted, beta, aggregate)
}

#' False Discovery Rate (FDR)
#' @usage
#' # 1) `fdr()`-function
#' fdr(
#'   actual,
#'   predicted,
#'   aggregate = FALSE
#' )
#'
#' @inherit specificity
#'
#' @details
#'
#' The False Discovery Rate (FDR). The metric is calculated for each class \eqn{k} as follows,
#'
#' \deqn{
#'   \frac{\#FP_k}{\#TP_k+\#FP_k}
#' }
#'
#' Where \eqn{\#TP_k} and \eqn{\#FP_k} is the number of true psotives and false positives, respectively, for each class \eqn{k}.
#'
#'
#' @family classification
#' @export
fdr <- function(actual, predicted, aggregate = FALSE) {
    .Call(`_SLmetrics_fdr`, actual, predicted, aggregate)
}

#' False Exclusion Rate (FER)
#'
#' Calculate the FER.
#'
#' @usage
#' fer(
#'   actual,
#'   predicted,
#'   aggregate = FALSE
#' )
#'
#' @inherit specificity
#'
#' @details
#'
#' The False Exclusion Rate is the False Omission Rate (FOR which is a reserved keyword). The metric is calculated for each class \eqn{k} as follows,
#'
#' \deqn{
#'   \frac{\#FN_k}{\#FN_k+\#TN_k}
#' }
#'
#' Where \eqn{\#FN_k} and \eqn{\#TN_k} is the number of false negatives and true negatives, respectively, for each class \eqn{k}.
#'
#' @family classification
#' @export
fer <- function(actual, predicted, aggregate = FALSE) {
    .Call(`_SLmetrics_fer`, actual, predicted, aggregate)
}

#'  False Positive Rate (fpr)
#' @usage
#' # 3) `fpr()`-function
#' fpr(
#'   actual,
#'   predicted,
#'   aggregate = FALSE
#' )
#'
#' @inherit specificity
#'
#' @family classification
#' @export
fpr <- function(actual, predicted, aggregate = FALSE) {
    .Call(`_SLmetrics_fpr`, actual, predicted, aggregate)
}

#' @rdname fpr
#' @export
fallout <- function(actual, predicted, aggregate = FALSE) {
    .Call(`_SLmetrics_fallout`, actual, predicted, aggregate)
}

#' Cohens \eqn{\kappa}-statistic
#'
#' @description
#'
#' Cohens
#'
#' @usage
#' kappa(
#'   actual,
#'   predicted,
#'   beta = 0
#' )
#'
#' @inheritParams cmatrix
#' @param beta A <[numeric]> value of [length] 1. 0 by default. If set to a value different from zero, the off-diagonal confusion matrix will be penalized.
#'
#'
#' @details
#' This function calculates the penalized kappa statistic as:
#'
#'   \deqn{\kappa = 1 - \frac{n_{disagree}}{n_{chance}}}
#'
#' where \eqn{n_{disagree}} is the weighted disagreement, and
#' \eqn{n_{chance}} is the expected disagreement by chance. The function
#' operates as follows:
#'
#' 1. **Confusion Matrix**: The confusion matrix \eqn{C} is calculated based
#'    on the input vectors \code{actual} and \code{predicted}.
#'
#' 2. **Penalizing Matrix**: A penalizing matrix \eqn{P} is created using
#'    \code{seqmat}, based on the dimensions of the confusion matrix.
#'    The penalizing matrix assigns weights to each element based on the
#'    absolute differences between the row and column indices, raised to the power \eqn{\beta}.
#'    When \eqn{\beta = 0}, the matrix elements corresponding to perfect agreement
#'    (i.e., the diagonal elements) are set to 0, while all other entries are set to 1.
#'    For higher values of \eqn{\beta}, the penalties grow as the absolute difference between the
#'    indices increases, giving greater penalization to more severe misclassifications.
#'
#' 3. **Weighted Disagreement**: The observed weighted disagreement \eqn{n_{disagree}}
#'    is calculated as:
#'    \deqn{n_{disagree} = \sum_{i,j} C(i,j) P(i,j)}
#'    where \eqn{C(i,j)} is the confusion matrix entry at row \eqn{i}, column \eqn{j}, and
#'    \eqn{P(i,j)} is the corresponding penalizing matrix entry.
#'
#' 4. **Expected Agreement**: The expected agreement by chance \eqn{n_{chance}} is
#'    calculated based on the marginal row and column sums:
#'    \deqn{n_{chance} = \sum_{i,j} \frac{R_i C_j}{N} P(i,j)}
#'    where \eqn{R_i} is the sum of row \eqn{i} of the confusion matrix, \eqn{C_j} is the
#'    sum of column \eqn{j}, and \eqn{N} is the total number of observations.
#'
#' The penalized kappa statistic then measures the agreement adjusted for chance,
#' while penalizing different types of misclassifications depending on their severity
#' (as controlled by \eqn{\beta}).
#'
#' @family classification
#'
kappa <- function(actual, predicted, beta = 0) {
    .Call(`_SLmetrics_kappa`, actual, predicted, beta)
}

#' Positive Likelihood (LR+)
#' @usage
#' plr(
#'   actual,
#'   predicted,
#'   aggregate = FALSE
#' )
#'
#' @inherit specificity
#'
#' @seealso
#'
#' The [nlr()]-function for the Negative Likehood Ratio (LR-)
#'
#' @family classification
#' @export
plr <- function(actual, predicted, aggregate = FALSE) {
    .Call(`_SLmetrics_plr`, actual, predicted, aggregate)
}

#' Negative Likelihood Ratio (LR-)
#'
#'
#' @usage
#' nlr(
#'   actual,
#'   predicted,
#'   aggregate = FALSE
#' )
#'
#' @inherit specificity
#'
#' @seealso
#'
#' The [plr()]-function for the Positive Likehood Ratio (LR+)
#' @family classification
#' @export
nlr <- function(actual, predicted, aggregate = FALSE) {
    .Call(`_SLmetrics_nlr`, actual, predicted, aggregate)
}

#' Negative Predictive Value (NPV)
#'
#' @description
#' Calculate the sensitivity
#'
#' @usage
#' npv(
#'   actual,
#'   predicted,
#'   aggregate = FALSE
#' )
#'
#' @inheritParams recall
#'
#' @family classification
#'
#' @export
npv <- function(actual, predicted, aggregate = FALSE) {
    .Call(`_SLmetrics_npv`, actual, predicted, aggregate)
}

#' Precision (Positive Predictive Value)
#'
#'
#' @description
#' Calculate the Precision
#'
#' @usage
#' # 1) `precision()`-function
#' precision(
#'   actual,
#'   predicted,
#'   aggregate = FALSE
#' )
#'
#' @inheritParams accuracy
#' @param aggregate A <[logical]>-value of [length] 1. [FALSE] by default. If [TRUE] it returns the
#' micro average across all k-classes
#'
#'
#' @details
#'
#' The precision is calculated as,
#'
#' \deqn{
#'   \frac{TP}{TP + FP}
#' }
#'
#' Where \eqn{TP} is the number of True Positives, and \eqn{FP} is the number
#' of False Positives.
#'
#'
#' @example man/examples/scr_precision.R
#'
#' @returns
#' A named <[numeric]> vector of length k
#'
#'
#' @family classification
#'
#' @export
precision <- function(actual, predicted, aggregate = FALSE) {
    .Call(`_SLmetrics_precision`, actual, predicted, aggregate)
}

#' @rdname precision
#'
#'
#' @usage
#' # 2) `ppv()`-function
#' ppv(
#'   actual,
#'   predicted,
#'   aggregate = FALSE
#' )
#'
ppv <- function(actual, predicted, aggregate = FALSE) {
    .Call(`_SLmetrics_ppv`, actual, predicted, aggregate)
}

#' Recall (Sensitivity)
#'
#' @description
#' Calculate the sensitivity
#'
#' @usage
#'  # 1) `recall()`-function
#' recall(
#'   actual,
#'   predicted,
#'   aggregate = FALSE
#' )
#' @inheritParams accuracy
#' @param aggregate A <[logical]>-value of [length] 1. [FALSE] by default. If [TRUE] it returns the
#' micro average across all k-classes
#'
#'
#' @details
#'
#' The sensitivity is calculated as,
#'
#' \deqn{
#'   \frac{TP}{TP + FN}
#' }
#'
#' Where \eqn{TP} is the number of True Positives, and \eqn{FP} is the number
#' of False Positives.
#'
#' @returns
#' A named <[numeric]> vector of length k
#'
#'
#' @family classification
#'
#' @export
recall <- function(actual, predicted, aggregate = FALSE) {
    .Call(`_SLmetrics_recall`, actual, predicted, aggregate)
}

#' @rdname recall
#' @usage
#' # 2) `sensitivity()`-function
#' sensitivity(
#'   actual,
#'   predicted,
#'   aggregate = FALSE
#' )
#' @export
sensitivity <- function(actual, predicted, aggregate = FALSE) {
    .Call(`_SLmetrics_sensitivity`, actual, predicted, aggregate)
}

#' Specificity (True Negative Rate)
#'
#' @description
#' Calculate the specificity
#'
#' @usage
#' specificity(
#'   actual,
#'   predicted,
#'   aggregate = FALSE
#' )
#'
#' @inheritParams cmatrix
#' @param aggregate A <[logical]>-value of [length] 1. [FALSE] by default. If [TRUE] it returns the
#' micro average across all k-classes
#'
#' @returns A named <[numeric]>-vector of length k.
#'
#' @example man/examples/scr_specificity.R
#'
#'
#' @family classification
#'
#' @export
specificity <- function(actual, predicted, aggregate = FALSE) {
    .Call(`_SLmetrics_specificity`, actual, predicted, aggregate)
}

#' @rdname specificity
#'
#' @usage
#' tnr(
#'   actual,
#'   predicted,
#'   aggregate = FALSE
#' )
#' @export
tnr <- function(actual, predicted, aggregate = FALSE) {
    .Call(`_SLmetrics_tnr`, actual, predicted, aggregate)
}

#' @rdname specificity
#'
#' @usage
#' selectivity(
#'   actual,
#'   predicted,
#'   aggregate = FALSE
#' )
#' @export
selectivity <- function(actual, predicted, aggregate = FALSE) {
    .Call(`_SLmetrics_selectivity`, actual, predicted, aggregate)
}

#' Zero One Loss
#'
#' @param actual placeholder
#' @param predicted placeholder
#'
#'
#' @family classification
#'
#'
#' @export
zerooneloss <- function(actual, predicted) {
    .Call(`_SLmetrics_zerooneloss`, actual, predicted)
}

#' Huber Loss
#'
#' @description
#'
#' Calculate the Huber Loss. [whuberloss()] calculates the arithmetic weighted average, and [huberloss()] calculates the arithmetic average.
#'
#' @usage
#' # simple mean
#' huberloss(
#'   actual,
#'   predicted,
#'   delta = 1
#' )
#'
#' @param actual A <[numeric]>-vector of length N. The observed (continuos) response variable.
#' @param predicted A <[numeric]>-vector of length N. The estimated (continuos) response variable.
#' @param delta A <[numeric]>-vector of length 1. 1 by default. The threshold value for switch between functions (see details).
#'
#' @details
#'
#' The Huber Loss is calculated as,
#'
#' \deqn{
#'  \frac{1}{2} (y_i - \hat{y}_i)^2 ~for~ |y_i - \hat{y}_i| \leq \delta
#' }
#'
#' \deqn{
#'   \delta |y_i-\hat{y}_i|-\frac{1}{2} \delta^2 ~for~ |y_i - \hat{y}_i| > \delta
#' }
#'
#' for each \eqn{i},
#'
#'
#' @example man/examples/scr_huberloss.R
#'
#'
#' @family regression
#'
#' @returns A <[numeric]>-value of [length] 1.
#'
#' @export
huberloss <- function(actual, predicted, delta = 1) {
    .Call(`_SLmetrics_huberloss`, actual, predicted, delta)
}

#' @rdname huberloss
#' @usage
#' # weighted mean
#' whuberloss(
#'   actual,
#'   predicted,
#'   w,
#'   delta = 1
#' )
#' @param w A <[numeric]>-vector of [length] N. The weight assigned to each observation in the data. See [stats::weighted.mean()] for more details.
#' @export
whuberloss <- function(actual, predicted, w, delta = 1) {
    .Call(`_SLmetrics_whuberloss`, actual, predicted, w, delta)
}

#' Mean Absolute Error (MAE)
#'
#' Calculate the MAE using the [mae()]-function for the (arithmetic) simple mean, or [wmae()]-function for the (arithmetic) weighted mean.
#'
#' @usage
#' # MAE (Simple Mean)
#' mae(
#'   actual,
#'   predicted
#' )
#'
#'
#' @inherit huberloss
#'
#' @family regression
#'
#' @export
mae <- function(actual, predicted) {
    .Call(`_SLmetrics_mae`, actual, predicted)
}

#' @rdname mae
#'
#' @usage
#' # MAE (Weighted Mean)
#' wmae(
#'   actual,
#'   predicted,
#'   w
#' )
#' @export
wmae <- function(actual, predicted, w) {
    .Call(`_SLmetrics_wmae`, actual, predicted, w)
}

#' Mean Squared Error (MSE)
#'
#' Calculate the MSE using the [mse()]-function for the (arithmetic) simple mean, or [wmse()]-function for the (arithmetic) weighted mean.
#'
#' @usage
#' # simple mean
#' mse(
#'   actual,
#'   predicted
#' )
#'
#' @inherit huberloss
#'
#' @family regression
#'
#' @export
mse <- function(actual, predicted) {
    .Call(`_SLmetrics_mse`, actual, predicted)
}

#' @rdname mse
#'
#' @usage
#' # weighted mean
#' wmse(
#'   actual,
#'   predicted,
#'   w
#' )
#' @export
wmse <- function(actual, predicted, w) {
    .Call(`_SLmetrics_wmse`, actual, predicted, w)
}

#' Root Mean Squared Error (RMSE)
#'
#' Calculate the RMSE using the [rmse()]-function for the (arithmetic) simple mean, or [wrmse()]-function for the (arithmetic) weighted mean.
#'
#' @usage
#' # simple RMSE
#' rmse(
#'   actual,
#'   predicted
#' )
#'
#' @inherit huberloss
#'
#' @family regression
#'
#' @export
rmse <- function(actual, predicted) {
    .Call(`_SLmetrics_rmse`, actual, predicted)
}

#' @rdname rmse
#'
#' @usage
#' # weighted RMSE
#' wrmse(
#'   actual,
#'   predicted,
#'   w
#' )
#' @export
wrmse <- function(actual, predicted, w) {
    .Call(`_SLmetrics_wrmse`, actual, predicted, w)
}

#' Root Mean Squared Logarithmic Error (RMSLE)
#'
#' Calculate the RMSLE using the [rmsle()]-function for the (arithmetic) simple mean, or [wrmsle()]-function for the (arithmetic) weighted mean.
#'
#' @usage
#' # simple RMSLE
#' rmsle(
#'   actual,
#'   predicted
#' )
#'
#' @inherit huberloss
#'
#' @family regression
#'
#' @export
rmsle <- function(actual, predicted) {
    .Call(`_SLmetrics_rmsle`, actual, predicted)
}

#' @rdname rmsle
#'
#' @usage
#' # weighted RMSLE
#' wrmsle(
#'   actual,
#'   predicted,
#'   w
#' )
#'
#' @export
wrmsle <- function(actual, predicted, w) {
    .Call(`_SLmetrics_wrmsle`, actual, predicted, w)
}

#' \eqn{R^2}
#'
#' @description
#' Calculate the R squared of two <[numeric]> vectors.
#'
#' @usage
#' rsq(
#'   actual,
#'   predicted,
#'   k = 0
#' )
#' @inherit huberloss
#' @param k A <[numeric]>-vector of length 1. 0 by default. If k>0
#' the function returns the adjusted R squared.
#'
#' @details
#'
#' The \eqn{R^2} is calculated as,
#'
#' \deqn{
#'   1 - \frac{SSE}{SST} \frac{n-1}{n - (k + 1)}
#' }
#'
#' @family regression
#'
#' @returns A <[numeric]>-value of length 1.
rsq <- function(actual, predicted, k = 0) {
    .Call(`_SLmetrics_rsq`, actual, predicted, k)
}

