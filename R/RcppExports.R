# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Accuracy
#'
#' Calculate the proportion of correct predictions.
#'
#' @usage
#' accuracy(
#'   actual,
#'   predicted
#' )
#'
#' @inheritParams cmatrix
#'
#' @returns A <[numeric]>-vector of [length] 1
#'
#' @example man/examples/scr_accuracy.R
#'
#' @family classification
#'
#' @export
accuracy <- function(actual, predicted) {
    .Call(`_SLmetrics_accuracy`, actual, predicted)
}

#' Confusion Matrix
#'
#' @description
#' Placeholder
#'
#' @usage
#' cmatrix(
#'   actual,
#'   predicted
#' )
#'
#' @param actual A <[factor]>-vector of length n, and k levels.
#' @param predicted A <[factor]>-vector of length n.
#'
#' @example man/examples/scr_confusionmatrix.R
#' @family classification
#'
#' @details
#'
#' If the function is correctly implemented the resulting
#' confusion matrix is given as,
#'
#'
#' |            | A (Predicted)        | B (Predicted)   |
#' | ------------- |:-------------:| -----:|
#' | A (Actual)   | Value     | Value |
#' | B  (Actual)   |  Value    |  Value   |
#'
#'
#' @returns A named k x k <[matrix]>
#'
#' @export
cmatrix <- function(actual, predicted) {
    .Call(`_SLmetrics_cmatrix`, actual, predicted)
}

#' Generalized F Score
#'
#' @description
#' Calculate the F Score
#'
#' @usage
#' fbeta(
#'   actual,
#'   predicted,
#'   beta = 1,
#'   aggregate = FALSE
#' )
#'
#' @inheritParams cmatrix
#' @param beta A <[numeric]> vector of length 1. 1 by default, see details.
#' @param aggregate A <[logical]>-value of [length] 1. [FALSE] by default. If [TRUE] it returns the
#' micro average across all k-classes
#'
#' @details
#' The general F-score equation is given as follows,
#'
#' \deqn{F_{\beta} = (1+\beta^2) \frac{precision \times recall}{\beta^2 \times precision + recall}}
#'
#' if \eqn{\beta = 1} then it corresponds to the traditional F1 score.
#'
#' @returns
#' A named <[numeric]> vector of length k
#'
#' @family classification
#'
fbeta <- function(actual, predicted, beta = 1.0, aggregate = FALSE) {
    .Call(`_SLmetrics_fbeta`, actual, predicted, beta, aggregate)
}

#' Precision
#'
#' @description
#' Calculate the Precision
#'
#' @usage
#' precision(
#'   actual,
#'   predicted,
#'   aggregate = FALSE
#' )
#'
#' @inheritParams accuracy
#' @param aggregate A <[logical]>-value of [length] 1. [FALSE] by default. If [TRUE] it returns the
#' micro average across all k-classes
#'
#'
#' @details
#'
#' The precision is calculated as,
#'
#' \deqn{
#'   \frac{TP}{TP + FP}
#' }
#'
#' Where \eqn{TP} is the number of True Positives, and \eqn{FP} is the number
#' of False Positives.
#'
#' @returns
#' A named <[numeric]> vector of length k
#'
#'
#' @family classification
#'
#' @export
precision <- function(actual, predicted, aggregate = FALSE) {
    .Call(`_SLmetrics_precision`, actual, predicted, aggregate)
}

#' Recall
#'
#' @description
#' Calculate the Recall
#'
#' @inheritParams cmatrix
#' @param aggregate A <[logical]>-value of [length] 1. [FALSE] by default. If [TRUE] it returns the
#' micro average across all k-classes
#'
#' @example man/examples/scr_recall.R
#'
#' @family classification
#'
#' @export
recall <- function(actual, predicted, aggregate = FALSE) {
    .Call(`_SLmetrics_recall`, actual, predicted, aggregate)
}

#' Specificity
#'
#' @description
#' Calculate the specificity
#'
#' @usage
#' specificity(
#'   actual,
#'   predicted,
#'   aggregate = FALSE
#' )
#'
#' @inheritParams cmatrix
#' @param aggregate A <[logical]>-value of [length] 1. [FALSE] by default. If [TRUE] it returns the
#' micro average across all k-classes
#'
#' @returns A named <[numeric]>-vector of length k.
#'
#' @example man/examples/scr_specificity.R
#'
#'
#' @family classification
#'
#' @export
specificity <- function(actual, predicted, aggregate = FALSE) {
    .Call(`_SLmetrics_specificity`, actual, predicted, aggregate)
}

#' Zero One Loss
#'
#' @param actual placeholder
#' @param predicted placeholder
#'
#'
#' @family classification
#'
#'
#' @export
zerooneloss <- function(actual, predicted) {
    .Call(`_SLmetrics_zerooneloss`, actual, predicted)
}

#' Huber Loss
#'
#' @description
#' Calculate the Huber Loss of two <[numeric]> vectors.
#'
#' @usage
#' huberloss(
#'   actual,
#'   predicted,
#'   delta = 1,
#'   w     = NULL
#' )
#'
#' @param actual A <[numeric]>-vector of length N.
#' @param predicted A <[numeric]>-vector of length N.
#' @param delta A <[numeric]>-vector of length 1. 1 by default.
#' @param w An optional  <[numeric]>-vector of [length] n. [NULL] by default.
#'
#' @details
#'
#' The Huber Loss is calculated as,
#'
#' \deqn{
#'  \frac{1}{2} (y_i - \hat{y}_i)^2 ~for~ |y_i - \hat{y}_i| \leq \delta
#' }
#'
#' \deqn{
#'   \delta |y_i-\hat{y}_i|-\frac{1}{2} \delta^2 ~for~ |y_i - \hat{y}_i| > \delta
#' }
#'
#' for each \eqn{i},
#'
#'
#' @example man/examples/scr_huberloss.R
#'
#'
#' @family regression
#' @returns A <[numeric]>-value of length 1.
#' @export
huberloss <- function(actual, predicted, delta = 1, w = NULL) {
    .Call(`_SLmetrics_huberloss`, actual, predicted, delta, w)
}

#' Mean Absolute Error (MAE)
#'
#' Calculate the MAE of two <[numeric]>-vectors
#'
#' @param actual A <[numeric]>-vector of length N.
#' @param predicted A <[numeric]>-vector of length N.
#'
#' @returns A <[numeric]>-value of length 1.
#'
#' @family regression
#'
#' @export
mae <- function(actual, predicted) {
    .Call(`_SLmetrics_mae`, actual, predicted)
}

#' Mean Square Error (MSE)
#'
#' Calculate the MSE of two <[numeric]>-vectors
#'
#' @param actual A <[numeric]>-vector of length N.
#' @param predicted A <[numeric]>-vector of length N.
#'
#' @returns A <[numeric]>-value of length 1.
#'
#' @family regression
#'
#' @export
mse <- function(actual, predicted) {
    .Call(`_SLmetrics_mse`, actual, predicted)
}

#' Root Mean Square Error (RMSE)
#'
#' Calculate the RMSE of two <[numeric]>-vectors
#'
#' @param actual A <[numeric]>-vector of length N.
#' @param predicted A <[numeric]>-vector of length N.
#'
#' @returns A <[numeric]>-value of length 1.
#'
#' @family regression
#'
#' @export
rmse <- function(actual, predicted) {
    .Call(`_SLmetrics_rmse`, actual, predicted)
}

#' Root Mean Square Logarithmic Error (RMSLE)
#'
#' Calculate the RMSLE of two <[numeric]>-vectors
#'
#' @param actual A <[numeric]>-vector of length N.
#' @param predicted A <[numeric]>-vector of length N.
#'
#' @returns A <[numeric]>-value of length 1.
#'
#' @family regression
#'
#' @export
rmsle <- function(actual, predicted) {
    .Call(`_SLmetrics_rmsle`, actual, predicted)
}

#' R squared
#'
#' @description
#' Calculate the R squared of two <[numeric]> vectors.
#'
#' @usage
#' rsq(
#'   actual,
#'   predicted,
#'   k = 0
#' )
#'
#' @param actual A <[numeric]>-vector of length N.
#' @param predicted A <[numeric]>-vector of length N.
#' @param k A <[numeric]>-vector of length 1. 0 by default. If k>0
#' the function returns the adjusted R squared.
#'
#'
#' @details
#'
#' The \eqn{R^2} is calculated as,
#'
#' \deqn{
#'   1 - \frac{SSE}{SST} \frac{n-1}{n - (k + 1)}
#' }
#'
#' @family regression
#'
#' @returns A <[numeric]>-value of length 1.
rsq <- function(actual, predicted, k = 0) {
    .Call(`_SLmetrics_rsq`, actual, predicted, k)
}

#' Weighted Mean Square Error (WMSE)
#'
#' Calculate the weighted MSE of two <[numeric]>-vectors
#'
#' @param actual A <[numeric]>-vector of length N.
#' @param predicted A <[numeric]>-vector of length N.
#' @param w A <[numeric]>-vector of length N with sample weights.
#'
#' @returns A <[numeric]>-value of length 1.
#'
#' @family regression
#'
#' @export
wmse <- function(actual, predicted, w) {
    .Call(`_SLmetrics_wmse`, actual, predicted, w)
}

#' Weighted Root Mean Square Error (WRMSE)
#'
#' Calculate the weighted RMSE of two <[numeric]>-vectors
#'
#' @param actual A <[numeric]>-vector of length N.
#' @param predicted A <[numeric]>-vector of length N.
#' @param w A <[numeric]>-vector of length N with sample weights.
#'
#' @returns A <[numeric]>-value of length 1.
#'
#' @family regression
#'
#' @export
wrmse <- function(actual, predicted, w) {
    .Call(`_SLmetrics_wrmse`, actual, predicted, w)
}

